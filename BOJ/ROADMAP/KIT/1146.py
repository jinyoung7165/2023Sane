# 지그재그 서기
'''
1,2번째에 아무나 가능. 같은 값은 없음
2번째가 1번째보다 클 경우, 3번째에는 2번째보다 작은 값이 와야 함
    작은 경우, 2번째보다 큰 값이 와야 함
n번째에는 n-2 < n-1인 경우(앞이 앞앞보다 큰 경우), n < n-1 (앞보다 작은 거)
n-2 > n-1인 경우(앞이 앞앞보다 작은 경우), n > n-1. (앞보다 큰 거 와줘야 함)
5명을 세운다고 치면, 1-3-2-5-4, 3-2-5-1-4 방법으로 세울 수 있음
n(1~100)명을 세운다고 할 때, 경우의 수 10**6로 나눈 나머지를 출력
앞이 내림차순 + 새로 온 제일 큰 숫자 + 뒤가 오름차순
...\/\/(현재수)\/\/\...
내림차순으로 시작 ->(a선택) 현재 위치에 a 놓고, 다음 위치의 수는 a보다 작아야 함 -> (b 선택)다음 수는 b보다 커야 함 ...
오름차순으로 시작 -> 위의 경우와 count 같을 것 -> 2배하면 됨
각 수 놓으며, (기준 수 계속 바뀜)남은 수 중, 나(기준 수)보다 작은 수 개수, 나보다 큰 수 개수 보면 됨

(내림차순으로 시작. 내림오름내림오름...)
n길이 결과수열의 [0]위치의 수 선택, ... [n]위치의 수 선택
-> i번째 수 선택 시, 나보다 작은 수 i개, 나보다 큰 수 n-i-1개 남음
-> 내림차순이므로 나보다 큰 수 와야 함 -> [0]번째 위치 이미 선택한 거임
-> 총 길이가 n-1인 결과수열의 [0],[1],...[n-1] 위치의 수 선택.
-> 남은 수 중, j번째 수를 [0]번째로 선택 시, 가능한 지그재그 수...

각 남은 수들의 후보 리스트를 매번 만들 수 없기 때문에,
남은 수들을 직전에 선택한 수를 기준으로 분할해 left, right의 새로운 리스트로 만든다고 가정
이 때, 원본 idx를 알 필요 없이, 남은 수들을 합쳤다고 가정하고, 가상 리스트 내의 상대적 idx만 알면 됨
남은 양옆 구간의 크기만 넘겨주면  그중에서 상대적으로 몇 번째인지 알 수 있음(처음부터 정렬돼 있음) -> 얘를 기준으로 다시 양 옆 분할 가능

이때, 길이가 1인 수열의 [0] 위치의 수 선택할 때, 남은 수를 그대로 써주면 됨

선택한 기준 수의 크기는 중요하지 않고, 걔보다 큰 거, 작은 거 몇 개가 남았는지에 따라 경우의 수가 달라짐
dp[i][j]: 방금 선택한 기준 수 왼쪽에 i개, 오른쪽에 j개 남았을 때, i+j크기의 결과수열(지그재그) 만들 수 있는 경우의 수
방금 선택한 기준 수 왼쪽에 0개, 오른쪽에 0개 남았을 때, n개 모두 잘 선택한 거임
'''
n = int(input())
dp = [[0]*100 for _ in range(100)]

def dfs(left, right): # right 구간에서만 다음 수 선택할 것
    size = left + right # 선택하지 않은=후보군의 크기만큼의 결과 수열 만들 것
    if size == 0: return 1 # n개 모두 선택한 것
    if right == 0: return 0 # 선택지 없음
    if dp[left][right]: return dp[left][right] # 이미 구한 결과 있으면 반환
    
    result = 0
    for i in range(right):
        # 직전에 선택한 수(기준) 오른쪽의 선택지 크기는 right.
        # 주어진 선택지가 새로운 리스트의 [0],...[right-1]번째 수들을 담은 배열이라고 간주
        # 그 중, [i]번째 수를 새로운 기준으로선택할 건데, 걔의 왼쪽에 남은 수들도 갱신해야 함: left+i개 남음
        # -> 새로운 선택(기준) 왼쪽의 남은 수 개수는 left+i, 오른쪽의 남은 수 개수는 right-1-i
        # 해당 개수를 기준으로 새로운 왼쪽 구간, 오른쪽 구간 배열 새롭게 생성했다고 간주
        # 구간의 크기 줄었기 때문에, 이미 사용한 [i]번째 수는 자연스럽게 [i+1]의 원소가 채우며 빠짐
        # 이때, 지그재그로 오->왼->오->왼 선택해야 하므로, left, right 구간의 크기 swap
        result += dfs(right-1-i, left+i)
    dp[left][right] = result
    return result
    

if n == 1: print(1) # 규칙 없는 예외적 상황
else:
    answer = 0 
    # n길이의 수열 만들 건데(오름차순으로 시작)
    # i번째의 수를 [0]으로 선택할 때, 가능한 다음 경우 재귀
    # 길이 n 결과수열의 [0]위치에 i 선택해 둘 것 -> 원소 n-1개 남음
    # 나보다 작은 부분 i개 [0~i-1], 나보다 큰 애 n-i-1개 [0~n-i-2] 새로운 구간 생성할 것
    # -> 남은 선택지의 길이만큼의 결과수열 생성할 것
    # 나보다 큰 구간에서->작은 구간에서->큰 구간에서 선택해야 하는데,
    # 재귀하며 left, right 구간 swap해주고, right구간에서만 선택하면 됨
    for i in range(n):
        answer +=  dfs(i, n-i-1)
    print(answer*2 % 10**6) # 내림차순의 경우도 고려