# 데스노트
'''
이름 주어진 순대로 각 줄에 적을 것
왼->오. 한 줄 끝나면 다음 줄에
각 이름 사이에는 한 칸의 공백 필요
대신, 줄의 끝에서 이름이 잘리면 안됨 
-> 현재 줄에 이름 더 쓸 수 있어도, 몇 개의 이름을 다음 줄로 넘길지 결정
각 줄의 끝에 공백의 개수**2의 합을 최소로 할 것
마지막 줄 맨끝의 공백은 포함x
-> 마지막 줄 공백 어차피 안 보므로, 최대한 적게 두면 이득
-> 제곱의 합이니까. max를 최대한 적게 해서, 골고루 퍼뜨려야 함

노트 폭 20일 때, 이름 길이 7, 4, 2, 3, 2, 5, 1, 12, 7, 5, 6 로 주어질 때
7_4_2_____(5)
3_2_5_1______(6)
12_7(0)
5_6__...(마지막 줄이라 0)

각 단어의 개수 n(1 ≤ n ≤ 1,000)
일단 현재 줄에 둔다고 치고, 안되면 backtrack -> 시간초과
점화식 모르겠는데 맨 마지막 순서의 식이 간단하다? bottom-up으로 한번 더 생각
dp[i]: i번째 원소부터 아래로 내려가며 줄을 묶을 때, 최소 누적제곱합. 각 경우를 다 봐야 최선이었는지를 알 수 있음 -> dfs+dp
dp[n-1]: 항상 0 -> dp[0]을 구하자
0~n-1 내려가며 i번째 원소만 포함할지, 이후 원소들도 포함할지 결정. 
원소 다 쓴 순간부터 dp[n-1]까지 0 => 다시 위로 올라가며 누적 제곱합에 더해줌 -> min(dp[0])
'''
from sys import stdin, setrecursionlimit
input = stdin.readline
n, m = map(int, input().split()) # m: 노트 폭. 각 이름은 m길이를 넘지 않음
names = list(int(input()) for _ in range(n))
M = m*m*n
dp = [M]*(n+1) # 각 줄~맨 마지막까지의 공백제곱합
dp[n] = 0
setrecursionlimit(10**6)

def dfs(idx): # idx줄부터 아래로 줄 합치며 누적 제곱합 반환
    if dp[idx] < M: return dp[idx] # 이미 idx번째 원소~맨 아래까지 여러 경우로 묶어볼 때 최소 확인함
    
    remain = m - names[idx] # 일단 idx번째 원소는 무조건 포함. 그 밑에 것도 포함할지 결정
    for nxt in range(idx+1, n+1): # 그 밑줄 원소도 포함한 경우도 고려(줄합치기)
        if remain >= 0: # 일단 현재 줄까지 합치기 가능
            if nxt == n: # n-1줄까지 remain에 포함함 -> 마지막 줄이라는 뜻. 현재 공백을 0으로 만들어버림
                dp[idx] = 0
                break
            dp[idx] = min(dp[idx], remain**2 + dfs(nxt)) # 현재 줄의 공백 제곱 + 아직 포함하지 않은 원소들이 만드는 줄들의 공백 제곱
            remain -= names[nxt] + 1 # 다음 원소도 포함
    return dp[idx]

print(dfs(0))