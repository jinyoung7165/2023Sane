# 합분해
# 0-n 정수 k개 더해 합이 n되는 경우의 수
# 덧셈 순서 바뀌면 다른 경우로 셈 (2+1과 1+2 다른 경우)
# 한 개의 수 여러 번 쓸 수 있음
# 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.
# 0,1,2 정수 2개 더해 합이 2되는 경우.
# 1개 더해 합이 0,1,2 되는 경우
# 0, 1, 2
# 2개 더해 합이 0,1,2 되는 경우
# 0+0, 0+1,1+0, 
# 1+1, 2+0, 0+2 -> 3
# 0,1,2,3 정수 3개 더해 합이 3되는 경우
# dp[3][3] = {(0,3,0),(0,0,3), (3,0,0), (0,1,2),(1,2,0),(1,0,2), (0,2,1),(2,1,0),(2,0,1), (1,1,1)}
# 0,1,2,3 정수 2개 더해 합이 3되는 경우
# dp[n][k] : 정수 k개 더해 합이 n되는 경우
# dp[0][k] : 1 {0,0,0..k개}
# dp[0][1] : 1 {0}
# dp[1][1] : 1 {1}
# dp[1][2] : 2 {1,0},{0,1}
# dp[1][3] : 3 {0,0,1},{1,0,0},{0,1,0}

# dp[1][k] : k (0사이 1의 위치 k번 달라짐)
# dp[n][1] : 1

# dp[2][1] : 1 {2}
# dp[2][2] : 3 {0,2},{1,1},{2,0} = dp[2][1]+dp[1][2]
# dp[2][3] : 6 {(0,0,2),(0,2,0),(0,1,1),(2,0,0),(1,1,0),(1,0,1)} = dp[2][2]+dp[1][3]

# dp[3][1] = 1 {3}
# dp[3][2] = 4 {(0,3),(3,0), (1,2),(2,1)} = dp[0][1]dp[3][1] + dp[1][1]dp[2][1] + dp[2][1]dp[1][1] +dp[3][1]dp[0][1]
# dp[3][3] = 10 = dp[3][2]+dp[2][3]
# 0+3을 2개로 나눈 것, 1+2를 2개로 나눈 것, 2+1을 2개로 나눈 것, 3+0을 2개로 나눈 것
# dp[n][k] = dp[0][k-1]+dp[1][k-1]+..dp[n][k-1]
# = dp[n-1][k] + dp[n][k-1]
# n최대 200, k최대200.
# 완전 탐색dfs만 이용 시 중복 방문 줄이자->dp

n, k = map(int,input().split())
dp = [[0] * (k+1) for _ in range(n+1)]
dp[0][0] = 1
# dp[0][1] = dp[-1][1](맨뒤에서 접근.어차피 0) + dp[0][0] = 0+1
for i in range(0, n+1):
    for j in range(1, k+1):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
print(dp[n][k] % 1000000000)